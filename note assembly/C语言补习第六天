冒泡排序：两两比较交换，一次确定一个数
简单选择排序：假设一个最大值与后面的数比较，找出最大值，与假设值进行交换，一次确定一个数

二维数组：
数据类型（数组内元素的数据类型）    数组名[行标][列标]

引用二维数组内元素可以通过   数组名[行标][列标]

二维数组初始化：
完全初始化：
不完全初始化：


通过双层for循环可以遍历数组内元素（遍历行标，列标）

二维数组数组大小：  数组内元素的数据类型x数组内元素个数（行x列）


字符数组：

char   数组名[下标]

字符数组初始化可以通过字符串直接赋值

char  a[] = "hello"
char a[] = {"hello"};
char a[] = {'h','e','l','l','o','\0'};

ascii码数组
char  a[] = {'h','e','l','l','o'};

%s  打印字符串（从字符串头开始打印直到'\0'截止）

字符串输出函数
puts
int puts(const char *s);
功能：向屏幕输出字符串，并在结尾自动加'\n'换行
参数：字符串
说明：输出字符串时默认以'\0'为结尾


字符串输入函数
gets
char *gets(char *s);
功能：从键盘获取一串字符串，自动在结尾加'\0'，用字符数组存放获取的字符串
注意：
1.char a[15]  这个字符数组做多只能存放14个字符，留下一个空间给'\0'
如果输入数据过多导致数组越界会出现Aborted (core dumped)（段错误）
2.scanf使用%s输入时无法识别space tab 和enter，因为scanf默认使用这三个作为输入结束的条件
gets只使用enter作为输入结束的条件，space可以被gets吃入


底行模式使用 man手册   ：  Man  3   函数名


字符串函数
#include <string.h>

strlen   
 size_t strlen(const char *s)
功能：计算字符串的长度，到'\0'截止，并且不计算'\0'
返回值：size_t   (unsigned int)
	返回的是字符串的长度
参数：字符串

strcpy字符串拷贝函数
char *strcpy(char *dest, const char *src);
功能：将源字符串拷贝到目标字符串，连同'\0'一同拷贝
返回值：dest的地址
参数：
第一个参数目标字符串（不能放字符串常量，只能放字符数组）     第二个参数源字符串（字符串常量，字符数组都可以）
Segmentation fault (core dumped)对常量进行修改出现段错误
注意：保证dest的空间足够大，不然造成数组越界

strcat字符串拼接函数
 char *strcat(char *dest, const char *src);
功能：将源字符串拼接到目标字符串的尾部，删除目标字符串的‘\0’
参数：
第一个参数目标字符串（不能放字符串常量，只能放字符数组）     第二个参数源字符串（字符串常量，字符数组都可以）
返回值：dest的地址
注意：1.保证dest的空间足够大
	
strcmp字符串比较函数
 int strcmp(const char *s1, const char *s2);
功能：逐个比较字符串s1和s2,当遇到不同的字符时，或者遇到‘\0’截止
（本质比较ascii码）

返回值：
当s1 > s2 时返回正整数    1
当s1 == s2时返回0
当s1 < s2时返回负整数    -1


作业：寻找特殊值

这个值是该行的最大，也是对应一列的最小


















