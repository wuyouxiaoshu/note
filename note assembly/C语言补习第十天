gcc 
预处理
编译
汇编
链接·

整型
计算机中所有数据按补码存放
将最高位置为符号位  1 负数（原码除符号位不变，取反+1）   0正数  （补码就是原码本身）
char（字符型） 本质是整型数值类型     -128~127    0~255    unsigned无符号
数据越界       
10E
100001110
129
1000 0001

1111 1111  -127

short
int
long

浮点型
float      6     7

double

常量：
整型
浮点型
指数形式:
1.23x10^2
1.23e+2
"   "
'    '
#define     标识符     被替换的     预处理

变量
全局变量：
局部变量：
存储类型   数据类型   变量名
auto   不能修饰全局变量
register
extern
static
修饰局部变量   改变局部变量存放位置，存放到全局区，延长生命周期，


强制数据类型转换
算术：
赋值：=

不会改变数值本身的类型！！！！！
int a;
char* p  = (char *)&a

int *p = &a
(char )*p
p+1

算术


/:取整
%:取余，只能在整型运算中使用
++a
a++
关系运算符

==        =


逻辑运算符
！
||
与1或为1
与0或不变
逢1截止
&&
与0与为0
与1与不变
逢0截止

位运算符
对数据的补码进行操作
~
&
|
^    相同为0相异为1
>>
<<

，
？
表达式1？表达式2：表达式3

sizeof（）

putchar（）
getchar（）
printf（）
普通字符：
%d
u
c
x
o
s
p
f
修饰符
m
.n
-
#
l
scanf（）

*
%d%c


if（表达式）
{
	
}

if（表达式）
{
	
}
else
{
	
}

if()
{
	
}
else if()
{
	
}
else if()
{
	
}
else
{
	
}

if()
{
	if()
	{

	}
	else
	{

	}	
}
else
{
	
}

switch(表达式)
{
	case  常量表达式
		break；

	default：
}

while（表达式）
{
	量的改变
}

do
{
	
}while（）；

for（表达式1；表达式2；表达式3）
{
	4
}

for()
{
	for()
	{

	}
}

数组：
1.数组是变量的集合2.数组内元素在内存上有序排放3.在数组内的元素要求数据类型一致

一维数组：
数据类型（数组内元素的数据类型）    数组名[下标]（数组内元素的个数）

int  a[6]  名字为a的数组里面有6个整型的数据

初始化：
完全初始化：

不完全初始化：剩余空间默认为0

数组名+下标代表数组内元素(下标从0开始) 
int a[6]
a[0] 数组内第一个元素
a[5] 数组内最后一个元素
a[6] 不存在  数组越界值

for遍历数组下标实现对数组的赋值或者引用

int  a[5]      ====>>     int  [5]   构造类型      元素数据类型大小x元素个数（数组大小）
 
 冒泡排序：两两交换，一次确定一个值

 简单选择排序：假设值，进行比较，比较结束后进行一次交换，一次确定一个数

二维数组：
数据类型    数组名[行标][列标]

数据类型 [列标]  数组名[行标]

数组名+行标+列标（0开始）

int  a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
int a[3][4] = {1,2,3,4,5,6};
int a[3][4] = {{1,2},{3,4,},{5,6}};
int a[][4] = {1,2,3,4,5,6,7,8};

双层for循环遍历二维数组内容

自动贩卖机
可乐  3
雪碧  3
芬达  3
牛奶  4
咖啡  5
脉动  6
红牛  5
农夫山泉 2


身份证校验
32028319900801123   ？

7  9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2

    sum%11     10

0~9   X ==10
       0 1 2 3 4 5 6 7 8 9 10
Y    1 0  x  9 8 7 6 5 4 3 2  

指针：
地址：
指针变量：

内存以每个字节为单位进行划分，每一个字节分配一个内存编号（门牌号）即该字节的地址

指针变量存放地址
一般类型
数据类型（指针指向数据的数据类型）    *指针变量名

int a  = 10；

&：取地址符
int    *p = &a

*：取地址里的值

*（&a） = a
p  == &a
*p = a

野指针
int *p    p里面是随机值   
*p   段错误

空指针
int*p = NULL  0地址空间

指针运算
p+1   
p++  p = p+1
p-q
p > q   地址值比较
  
int * p   ===>>  int * 指针类型

int a[6]  
















































































gets（）
puts（）






























































