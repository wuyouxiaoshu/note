gcc编译器
C语言源文件编译生成二进制可执行文件

gcc   文件名.c
a.out 
./a.out

预处理
不进行代码的校验（正确性检查），进行头文件的展开和宏替换，生成经过预处理的文件  xxx.i
gcc -E hello.c  -o hello.i

编译
将预处理过的文件进行代码的校验，有错报错，没有错生成对应的汇编语言文件
gcc -S hello.i  -o  hello.s

汇编
对汇编文件进行汇编，并且生成二进制文件
gcc -c hello.s -o hello.o

链接
将二进制文件链接生成二进制可执行文件
gcc hello.o  -o  hello
.E->.i->.s->.o

man 1 ：命令查询
man 2 ：系统调用
man 3 ：C库函数

运行内存（RAM）   速度快，断电易失性，上电工作
外部存储（ROM）   不易失
寄存器

二进制  0~1   逢2进1    前导符0b 
八进制  0~7   逢8进1    前导符0      1位八进制对应3位二进制
十六进制  0~9 a~f(10~15)  逢16进1   前导符0x   1位十六进制对饮4位二进制


注释：
//:代表注释符号后的一行无效
/*  .........*/:多行注释

#if 0
。
。
#endif
多行注释

ascii码表：
‘A’   65
‘a’   97
‘  ’   32

基本数据类型
逻辑类型
#include <stdbool.h>
bool
有值，值只有两种结果，逻辑真（1），逻辑假（0）
（C语言中衍生出：非0为真）

整型类型     1个字节 == 8个bit位
char（字符型）   1个字节  
unsigned   无符号      8位都是数据位   取值范围是0~255（总共256个数） 
signed       有符号    （不写的情况下默认有符号）
默认将最高位的数据位变成符号位（正数符号位为0，负数符号位为1）
计算机中所有的数据以补码的形式存放（我们转换的二进制是原码）
正数
10
原码，反码，补码都和原码相同
0 000 1010 原码
0 000 1010 反码
0 000 1010 补码
负数
-10
1 000 1010 原码
1 111 0101 反码（原码除符号位不变其余取反）
1 111 0110 补码（反码除符号位不变+1获得）

数据越界：不会报错，越界之后数据偏差特别大
例：
129（有符号情况下，char型范围是-128~127，越界）
129是个正数存放到内存中默认正数存放，补码和原码相同 1 000 0001
如果再次使用这个数，计算机默认有符号，最高位数据位1变成了符号位
，默认是一个负数的补码，根据负数的变换原则，补码-1取反变成原码
1 111 1111  得到-127

-128（临界值，无法正常讨论原码和反码，补码为 1 000 0000，所谓的（-0））

short(短整型)   2个字节
int             4个字节（32位操作系统）   2个字节（16位操作系统）     
long(长整形)    4个字节（32位操作系统）   8个字节（64位操作系统）

浮点型（默认编译器精度为6）
单精度
float      精度为6     4个字节   有效数为7位（连上小数点前的位数）

双精度
double  精度为16   8个字节  有效数为17位（连上小数点前的位数）

构造类型
指针类型
void类型

常量：程序运行过程中不能改变的量
整型常量   十进制   十六进制   八进制  二进制数
浮点型常量  
123.1234
指数形式
1.231234x10^2  数学上的科学计数法
1.231234e+2   浮点型的指数形式表达

字符型常量：用'  '引出   由于ascii码表，都是固定的数值
字符串常量：用"  "引出   结尾以'\0'结束
标识常量（宏替换）（在gcc编译时预处理完成了，本质是字符串的整体替换（*））
#define    标识符（PI） 被替换的量（常量，公式（注意运算符优先级），字符等）（3.1415926）

底行模式下输入 ： vsp  文件名（分屏显示）

变量：程序运行中可以改变的量

存储类型   数据类型（决定变量的大小和变量内存放的类型）    变量名

全局变量：不在{ }内的变量
局部变量：在{ }内的变量

存储类型：
auto：修饰局部变量，当不写存储类型时默认为auto类型，最常用最不常见

register（寄存器类型）：
将修饰的局部变量放到寄存器中，提高程序的运行效率，当寄存器放满时，register修饰的变量自动变成auto类型

extern(外部引用类型):
引用同一工程中的全局变量
声明：告诉程序变量有被定义但是并不在这边被定义
定义：在内存上开辟了对应的数据类型大小给变量使用

static（静态存储类型）：
修饰局部变量：1.修改局部变量的存储位置  2.延长局部变量的生命周期 3.运算结果保留上一次的运算结果
修饰全局变量：防止其他程序引用static修饰的全局变量
修饰函数：防止其他程序引用修饰的函数

 变量的初始化：在变量定义时对其进行赋值
 int a = 10；初始化操作（防止垃圾值得产生）
 a = 5;赋值操作

内存分段：
栈区：局部变量 和 函数参数
堆区：malloc  和 free
全局区：全局变量和static修饰的局部变量
代码区：常量和代码

强制数据类型转换：不安全，多用于指针操作
隐式：
double <-----  float
    |
   long <---- int <-----short <----- char
算术：
在同一个运算式中，所有的数据类型向最高的数据类型转换
赋值：
将右边的数据类型向左边的数据类型进行转换，右边数据类型大于左边数据类型会出现精度丢失（不遵循四舍五入直接放弃小数部分），数据越界.
‘=’：赋值运算符 将右边的值赋值给左边

显示：
（想要转换的类型）被转换的变量
1.高的数据类型向低的数据类型转换，可能造成数据越界
2.精度高的向精度低的装换，可能造成精度丢失
3.并没有改变变量本身的数据类型，只是显示的结果被改变了，参与运算时需要注意（显示的结果参与运算）

