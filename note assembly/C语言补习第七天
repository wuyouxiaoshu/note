地址：
指针：
指针变量：


内存以一个字节（byte）为单位划分内存，每一个字节都有一个地址编号（内存编号）

&（取地址符）：取出目标的地址（内存编号）
*（指针运算符）：取地址里的值

数据类型  * 指针变量名（存放地址值）
	|
指针指向的数据的数据类型

直接引用：
间接引用：指针操作都是间接引用

指针初始化：
int *p： 野指针
*p = 100；
对野指针进行操作会发生段错误（原因没有对指针初始化，指针中内容为随机值，即指针p指向一片随机的空间）   
Segmentation fault (core dumped)

int *p = NULL   空指针
NULL标号为0的地址空间，NULL空间受到保护，不能对NULL空间进行修改
如果对0地址空间进行修改会出现段错误
Segmentation fault (core dumped)

指针运算

+
p+1: 地址值+1不是数值得相加，是指地址的值向高地址方向偏移一个数据类型（指针指向的数据类型）大小    （p的指向没有发生改变）
-

p++: p = p+1 , p向地址高的方向偏移了一个数据类型大小
++p:

int *p    int   *q
p-q:指针p,q必须指向同一片连续的空间，且空间内数据的类型必须相同，运算的结果为相差数据的个数

指针的关系运算

p>q   比较p和q的地址值大小关系

指针的数据类型
int *p = &a

指针类型：在32操作系统中大小永远为4    本质是一个地址（8位16进制组成32bit）
指针变量p的数据类型就是int *

大小端：
大端：低地址存放高字节
小端：低地址存放低字节

一维数组：
一维数组数组名是首元素的地址！！！数组的首地址  （地址常量）

int  a[6]
 
a = &a[0]

a+1 = &a[0]+1 = &a[1]

*(a+1) = *(&a[0]+1) = *(&a[1]) = a[1];

得到：
*(a+n) = a[n]

指针是指针，数组是数组
当指针指向数组首地址时，指针与数组建立关系

int   a[6]
int *p = a;&a[0]//建立数组与指针之间的关系
p = a = &a[0]

p+1 = a+1 = &a[0] + 1 = &a[1]

*(p+1) = *(a+1) = *(&a[0]+1) = *(&a[1]) = a[1]

得到：
*(p+n) = *(a+n) = a[n] = p[n]

数组指针：本质是指针，指向一个数组

int   a[6];

&a:   这时a作为数组的一个代表，取的是整个数组空间的大小，虽然地址值和a（作为首元素的地址时），但是表示的空间大小不同  a代表a[0]的空间   &a代表整个数组空间

数组a的数据类型是int [6]
int [6] *p = &a；  代表指针p指向整个数组a

int (*p)[6] = &a;   数组指针p   注意（）必须要加！！   指针p指向的数据类型是int [6]
p的数据类型  int(*)[6]   

int *p = a；指针p指向的数据类型是int
p的数据类型  int *

二维数组数组名需要通过   数组指针接收

int  a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};

int [4] a[3]

int (*p)[4] = a
p = a = &a[0]  (a[0]数据类型是 int[4],a和&a[0]数据类型int(*)[4])

a +1 = p+1 = &a[0] +1 = &a[1];(跨过的数据类型大小为int[4])

*(a+1)  = *(p+1) = *(&a[1]) = a[1] (取出的是一行，a[1]表示一行数据类型 int [4],int a[1](可以看做数组名)  [4] )    第一表达式

p[1] = a[1] = &a[1][0] 

a[1] +1  = &a[1][0]+1 = &a[1][1]  (&a[1][1]的数据类型int*     a[1][1]的数据类型 int)

*(a[1]+1) = *(p[1]+1) = *(&a[1][1])  = a[1][1] = p[1][1](数据类型为int)
第二表达式


由表达式1与表达式2结合最终得到
*(*(a+i)+j) = *(*(p+i)+j) = a[i][j] = p[i][j]   i为行标  j为列标

作业：
删除空格
























































